# zombi_game.py
import os
import random
from dataclasses import dataclass
from typing import Tuple, List, Set

# =======================
# 1) KONFIGURATION
# =======================
WIDTH  = 20     # Spielfeldbreite
HEIGHT = 10     # SpielfeldhÃ¶he
NUM_ZOMBIES = 5 # Anzahl Zombies

PLAYER_SYMBOL = 'T'
ZOMBIE_SYMBOL = 'I'
EXIT_SYMBOL   = 'O'
EMPTY_SYMBOL  = '.'

# =======================
# 2) DATENMODELLE
# =======================
Pos = Tuple[int, int]  # (x, y) mit x in [0..WIDTH-1], y in [0..HEIGHT-1]

@dataclass
class GameState:
    width: int
    height: int
    player: Pos
    exit: Pos
    zombies: List[Pos]
    running: bool = True
    won: bool = False

# =======================
# 3) HILFSFUNKTIONEN
# =======================
def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')

def in_bounds(x: int, y: int, w: int, h: int) -> bool:
    return 0 <= x < w and 0 <= y < h

def random_free_position(blocked: Set[Pos], w: int, h: int) -> Pos:
    while True:
        p = (random.randrange(w), random.randrange(h))
        if p not in blocked:
            return p

def render(state: GameState):
    grid = [[EMPTY_SYMBOL for _ in range(state.width)] for _ in range(state.height)]

    # Eintragen: Exit, Zombies, Player
    ex, ey = state.exit
    grid[ey][ex] = EXIT_SYMBOL
    for zx, zy in state.zombies:
        grid[zy][zx] = ZOMBIE_SYMBOL
    px, py = state.player
    grid[py][px] = PLAYER_SYMBOL

    # Rahmen + Spielfeld ausgeben
    top = '+' + '-' * (2 * state.width - 1) + '+'
    print(top)
    for row in grid:
        print('|' + ' '.join(row) + '|')
    print(top)

def read_move() -> Pos:
    # w,a,s,d oder q
    valid = {'w': (0, -1), 'a': (-1, 0), 's': (0, 1), 'd': (1, 0)}
    while True:
        move = input("Bewegung (w/a/s/d) oder q zum Beenden: ").strip().lower()
        if move == 'q':
            return ('q', 'q')  # spezieller Marker
        if move in valid:
            return valid[move]
        print("UngÃ¼ltige Eingabe.")

def move_pos(pos: Pos, delta: Pos, w: int, h: int) -> Pos:
    x, y = pos
    dx, dy = delta
    nx, ny = x + dx, y + dy
    if in_bounds(nx, ny, w, h):
        return (nx, ny)
    return (x, y)  # gegen Wand prallen (stehen bleiben)

def zombies_step(zombies: List[Pos], player: Pos, w: int, h: int) -> List[Pos]:
    new_positions = []
    for zx, zy in zombies:
        # ZufÃ¤llige Bewegung um 1 Feld (auch stehen bleiben ausgeschlossen)
        choice = random.choice([(1,0), (-1,0), (0,1), (0,-1)])
        nx, ny = move_pos((zx, zy), choice, w, h)
        new_positions.append((nx, ny))
    return new_positions

def check_end(state: GameState):
    if state.player in state.zombies:
        state.running = False
        state.won = False
    elif state.player == state.exit:
        state.running = False
        state.won = True

# =======================
# 4) INITIALISIERUNG
# =======================
def init_game(w: int, h: int, n_zombies: int) -> GameState:
    blocked: Set[Pos] = set()
    player = random_free_position(blocked, w, h); blocked.add(player)
    exit_pos = random_free_position(blocked, w, h); blocked.add(exit_pos)

    zombies: List[Pos] = []
    for _ in range(n_zombies):
        z = random_free_position(blocked, w, h)
        zombies.append(z)
        blocked.add(z)

    return GameState(width=w, height=h, player=player, exit=exit_pos, zombies=zombies)

# =======================
# 5) HAUPTSCHLEIFE
# =======================
def main():
    state = init_game(WIDTH, HEIGHT, NUM_ZOMBIES)

    while state.running:
        clear_screen()
        print(f"Zombi-Game  |  Feld: {state.width}x{state.height}  |  Zombies: {len(state.zombies)}")
        render(state)
        step = read_move()
        if step == ('q', 'q'):
            print("Spiel beendet.")
            return

        # Spieler bewegt sich
        state.player = move_pos(state.player, step, state.width, state.height)
        check_end(state)
        if not state.running: break

        # Zombies bewegen sich
        state.zombies = zombies_step(state.zombies, state.player, state.width, state.height)
        check_end(state)

    clear_screen()
    render(state)
    print("ðŸŽ‰ Gewonnen! Du hast den Ausgang erreicht." if state.won else "ðŸ’€ Verloren! Ein Zombi hat dich erwischt.")

if __name__ == "__main__":
    main()
